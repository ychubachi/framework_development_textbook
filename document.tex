\documentclass[a4j,papersize]{jsbook}

\usepackage[T1]{fontenc} % LaTeXのフォントのエンコーディングをT1にする
\usepackage{textcomp} % TS1
\usepackage[utf8]{inputenc} % ファイルのエンコーディングをUTF8にする
\usepackage{lmodern}

%\usepackage{url}

\usepackage{document} % 自作書式集

\usepackage[dvipdfmx,%
 bookmarks=true,%
 bookmarksnumbered=true,%
 colorlinks=true,%
 setpagesize=false,%
 pdftitle={Javaによる抽象化プログラミング技法},%
 pdfauthor={中鉢欣秀},%
 pdfsubject={教科書},%
 pdfkeywords={Java; Object-Oriented Programing; Framework;}]{hyperref}
\usepackage{pxjahyper}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 本文
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\title{オブジェクト指向フレームワーク原論}d
\title{Javaによる抽象化プログラミング技法}
\author{中鉢 欣秀}
\begin{document}
\maketitle
% \tableofcontents

\chapter*{序}

\begin{abstract}
寿限無寿限無五劫の摺り切れ海砂利水魚の水行末雲来末風来末．食う寝る所に
住む所藪柑子ブラコウジ．パイポパイポパイポのシューリンガングーリンダイ
のポンポコピーのポンポコナーの長久命の長助．
\end{abstract}

\section*{はじめに}

この教科書はオブジェクト指向言語の抽象化機構を最短で理解できることを目
指したものである．

ソフトウェアに関連する技術の移り変わりはとても早い．変わらない知識（普遍的な知識）を身につけることこそ，ソフトウェアのアーキテクトに求められることです．

ソフトウェア・アーキテクチャに関する本質的な知識．

オブジェクト指向の概念に基づくCBD（Component Based Development）を主要なトピックとします．
フレームワークの作り方を学ぶことで，上手な使い方を体得することが目標です．

フレームワークを作れるようになろう 

他人の作ったフレームワークを使って満足するだけ
でよいのか？ 

フレームワークを使えるようになろう 

フレームワークの作り方を学ぶことによって、既存
フレームワークをより深く理解することができる 

フレームワーク・プログラミングをとりあげる
理由 

ソフトウェア開発においては、ソフトウェアを部品
化（コンポーネント化）し、部品を再利用すること
で開発効率を上げるための試みが行われてきた。 

フレームワークの構築 

原始的なIPO構造の理解から順をおって、フレーム
ワーク構築までを行ないます。 

オブジェクト指向の最も有用な利用方法の一つとし
てフレームワークとプラグインによるアーキテク
チャ設計を理解しましょう。 

汎用的な技術 

ソフトウェアにおける「構造」とは？ 

オブジェクト指向によるフレームワークの設計 

応用的な技術 

Eclipseとプラグインを活用したソフトウェア開発 

実践的なフレームワークのアーキテクチャ 

ソフトウェアの中核的構造をフレームワークとして設計す
る考え方が普及した。 

目的に応じたコンポーネントをフレームワークにプ
ラグインすることで、最も重要で複雑な中核部分の
構造を再利用できるようにする。 

こうすることにより、プログラミングにおける省力化が達
成される。


javaの約束事や決まりごとは「おまじない」または「お約束」と説明するのが
慣例です．
このテキストでは，明確にそれらの解説への参照箇所を示します．

Java言語は初心者向けの言語ではありません．ごく簡単なプログラムであって
もいわゆる「おまじない」がいっぱい出てきます．

Java仕様書

\url{http://docs.oracle.com/javase/specs/jls/se7/jls7-diffs.pdf}

IPOフレームワーク

MVCフレームワーク

\chapter{フレームワークとはなにか}

\begin{abstract}
寿限無寿限無五劫の摺り切れ海砂利水魚の水行末雲来末風来末．食う寝る所に
住む所藪柑子ブラコウジ．パイポパイポパイポのシューリンガングーリンダイ
のポンポコピーのポンポコナーの長久命の長助．
\end{abstract}

\section{フレームワークの定義}
\subsection{フレームワークの一般的な定義 }

\begin{enumerate}
 \item 抽象クラスの集合とそのインスタンス間の相互作用によって表現された，
システムの全体または一部の再利用可能な設計
 \item 開発者がカスタマイズできる，アプリケーションの骨組み
\end{enumerate}

 出典） R.ジョンソン，中村宏明，中山裕子，吉田和樹著，
「パターンとフレームワーク」，共立出版 

簡単に言えば「枠組み」のことだ．

\subsection{フレームワークの重要な性質}
ハリウッド・プリンシプル 

映画監督のセリフ 

「Don’t call me, I call you」 

 ハリウッドの役者は，仕事が来るのをひたすら家で待って
いなくてはならない，という例え 

フレームワークは映画監督 

フレームワークの利用者が作成するコンポーネント
は，フレームワークを呼び出すのではなく，フレー
ムワークに呼び出されるのを待つ 

\subsection{フレームワークに関係する用語}

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=30mm 30mm 35mm
  35mm,clip]{framework.pdf}
  \caption{フレームワークのアーキテクチャ例}\label{fig:framework_architecture}
 \end{center}
\end{figure}

図\ref{fig:framework_architecture}にフレームワークのアーキテクチャを概
念的に示した．

\begin{description}
 \item[コンポーネント(component)] 1つまたはそれ以上のクラスからなる,特
	    定の目的を達成するソフトウェア部品．
 \item[フレームワーク・コンポーネント(framework component)] 再利用性の
	    あるロジックをコンポーネントにしたもので,後述のプラグイン
	    コンポーネントと併用することで,様々なアプリケーションに利
	    用できるソフトウェア部品．
 \item[プラグインコンポーネント(Plug-in Component)] フレームワーク・コ
	    ンポーネントに接続することを前提としたコンポーネントで,必
	    要に応じて作成・カスタマイズできる．
 \item[プラグ・ポイント(Plug point)] コンポーネントをフレームワークに
	    プラグインするために,フレームワークが用意する接続点
\end{description}

\section{フレームワークの作り方}
フレームワークの構築へ向けて

段階を追った学習

もととなるプログラムを段階的に進化させる
方針を立て、プログラミング演習で実装する

アーキテクチャの表現と設計

Java言語の各種のOO機能を活用して、フレームワー
クを構築します

クラス/インタフェイス/メソッド/フィールド/パッ
ケージ・・・

モデル(UML)によりアーキテクチャを表現する

\subsection{リファクタリング・アプローチ}

ボトムアップ・アプローチについて
この授業のスタート地点
 目的の異なる2つのプログラム
フレームワーク構築への道のり
 プログラムの「アーキテクチャ」を捉える
 共通するアーキテクチャを探し出す
 共通化のための方針を立てる
 2つの「上位概念」を考える
 フレームワークを完成させる
リファクタリングとの関連
 このアプローチはリファクタリングの一種でもある

\subsection{ボトムアップ VS トップダウン}

以上説明したボトムアップのアプローチに対して、トップダウンのアプローチというのもある

最初から抽象度の高いアーキテクチャを「モデル」
として設計し、プログラミングで実装する

ボトムアップを採用する理由

初心者にとって学習曲線が緩やかである

実際の開発の現場でも、トップダウンとボトムアッ
プは併用する

\section{IPOパターン}

最も単純なソフトウェアのアーキテクチャ
 IPO = Input + Process + Output
IPOとは?
 入力処理/中核となる計算処理/出力処理のこと
 株式公開(Initial Public Offering)のことではないです...
ソフトウェアのアーキテクチャの切り口
 IPOをフレームワークとして用いることができる

ソフトウェアはIPOから成り立つ．

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=10mm 30mm 10mm 45mm,clip]
   {IPO.pdf}
  \caption{IPOの模式図}
 \end{center}
\end{figure}

大きなIPOはさらに細かいIPO構造を含む．
最終的にはこれ以上細かくできない処理まで行き着く．

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=5mm 34mm 10mm 60mm,clip]
   {IPO_tree.pdf}
  \caption{IPOは階層構造になる}
 \end{center}
\end{figure}

最も細かい粒度のIPO

Input
 メモリや
 デバイス
 からデー
タを取り
 込む

Process
 CPUによ
 る演算
 処理

Output
 メモリや
 デバイス
 への
 データの
 送り込み

\section{MVCパターン}

% $ pdftk フレームワーク開発特論.pdf cat 29 output MVC.pdf
\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=25mm 70mm 60mm 30mm,clip]
   {MVC.pdf}
  \caption{MVC構造（サンプルに合わせて書き直す）}
 \end{center}
\end{figure}

MVC (Model-View-Controller)の重要性
 主にグラフィカルなインタフェースを備えたソフト
ウェアにおいて,広く一般的に利用するフレーム
ワークである
 近年では、Webアプリケーションの構築にも利用す
る
 ただし、伝統的なMVC構造とは異なっている

MVCは何に使われているのか?

GUIを含むアプリケーションの再利用技術

最初の本格的なオブジェクト指向言語である

SmallTalkで採用

MacintoshのUIでも使用

Microsoft Windowsでも採用

Webアプリケーションに適合するよう変化

MVCの構造を理解するには?

Model-View-Controllerの構造

出展)「パターンとフレームワーク」共立出版
MVCを達成するためのソースコードを書く

\subsection{GUIへの適用}
Java言語のSwingクラスライブラリを利用した
MVC構造の実現

自ら作成したMVCの構造を、Swingクラスライブラ
リと組み合わせることで、GUIアプリケーションとし
て完成させる

\subsection{開発環境を活用したプログラミング}
どういう開発環境を使うのか?
• 「Eclipse(エクリプス)」を用いる
• 主にJava言語を用いる開発環境のスタンダード
Eclipseを利用するメリット
• Eclipseはオープンソースの開発環境であり,無料で使うことができる
• コンパイルの自動実行や,文法誤りの発見などの支援を受けることができる
• 大規模なソースコードを管理する機能がある
• 強力なリファクタリング機能
フレームワークとしてのEclipse
• Eclipseそのものがフレームワークを学ぶ教材
• さまざまな機能拡張が可能で,開発者を支援するためのソフトウェア部品が
数多く存在する

\subsection{プログラミング言語は人間が作った}

我々が日常生活で使っている言語（日本語など）を自然言語とするならば，プ
ログラミング言語は人工言語だと言える．

http://merd.sourceforge.net/pixel/language-study/diagram.html

 主要な言語
 詳細な図(150言語以上)

プログラミング言語は人の手で作られた
 Pascalを作った人
 ニクラウス・ヴィルト
 Java言語を作った人
 ジェームズ・ゴスリン
 Perlを作った人
 ラリー・ウォール
 Rubyを作った人
 まつもとゆきひろ
\section{目的手段展開について}

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=10mm 18mm 20mm 30mm,clip]
   {mokuteki_shudan.pdf}
  \caption{目的手段展開の構造}
 \end{center}
\end{figure}

目的型と手段型のコメント比較

コメントには「目的(何をする・What)」を書
く

「手段(どうする・How)」はコードを読めば分か
る

手段型のコメント
\begin{verbatim}
	// totalをcountで割る
	average = total / count;
\end{verbatim}

目的型のコメント
\begin{verbatim}
	// 平均点を求める
	average = total / count;
\end{verbatim}

\subsection{コメント・ブロック}
コメントによるブロックの作り方．
コメントと空行の組み合わせ．

\begin{verbatim}
private void run() throws Exception {
    // ○○を入力する
    aaa();
    bbb();

    // ○○を計算する
    ccc();

    // ○○を出力する
    ddd();
}
\end{verbatim}



\section{演習問題}
\begin{演習}
身近な次のソフトウェアのIPOはそれぞれなにか?
 ウェブブラウザ
 ワードプロセッサ
 メールリーダ
 データベース
 OS 
\end{演習}

\begin{演習}
「全てのソフトウェアは必ずIPOを備える」は正しいか?
\end{演習}

\begin{演習}
(InputとOutputがない)Processだけのソフトウェアには価値があるか?
\end{演習}

\begin{演習}
IPOフレームワークに基づく「プログラムの価値(=プログラが何を目的として達成する
か)」とは?
\end{演習}

\begin{演習}
 次の???にコメントを書くとしたらどうします
か?
\begin{verbatim}
	double a = 4.56;
	// ???
	int b = (int) (a + 0.5);
	System.out.println(b);
\end{verbatim}
\end{演習}
\section{解答}
\begin{解答}
 視点(領域)の設定や、
粒度によって、答えは異なる
\end{解答}

\chapter{プログラムのアーキテクチャ}

\begin{abstract}
寿限無寿限無五劫の摺り切れ海砂利水魚の水行末雲来末風来末．食う寝る所に住む所藪柑子ブラコウジ．パイポパイポパイポのシューリンガングーリンダイのポンポコピーのポンポコナーの長久命の長助．
\end{abstract}

\section{プログラムの「開始点」}
あなたは,ここ1年以内に,業務で(大学の演習
等を除く)「開始点(mainメソッド)」のある
ソースコードを書いたことがありますか?
ない場合,その理由はなぜですか?

スターティングポイント
 どんなプログラムにも「開始点」がある

開始点の例
 Java言語の場合
 main()メソッド
 C言語の場合
 main()関数
 他の言語の場合は?
 ???

Javaのmain()メソッドはなぜstaticか?
仮にMainクラスがあり、コンパイル済みである
とき

 「java Main」コマンドでJVMが起動

 JVMは,クラスのインスタンスを生成しない

 したがって,Mainクラスの通常メソッドは呼び出せ
ない

考えてみよう

 もし,JVM起動時にMainインスタンスを自動生成す
ると?

 プログラマがMainクラスの初期化(コンストラクタへの引
数設定)を制御することができなくなってしまう

– 制御できない=プログラマはとても不自由になる

Javaのmain()でやるべきこと

本来,main()でやるべきこと
 (OSからの引数の受け取り処理)
 中心となる(Main)クラスのインスタンスの生成
 インスタンスの開始メソッド呼び出し
 など

注意

 教科書に出てくる短いサンプルならいざ知らず,
main()内に複雑なロジックを記述してはいけない

\section{クラスとインスタンス}

Java言語におけるクラスの取り扱い
 クラスを定義する
 インスタンスを生成する
 インスタンスを使用する
 具体的にはメソッド呼び出し

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=10mm 10mm 5mm 13mm,clip]
   {class_instance.pdf}
  \caption{クラスの定義とインスタンスの生成・使用}
 \end{center}
\end{figure}

section{メソッド}
コメントブロックの効果と問題
• プログラムのどの部分がIPOを担っているのかが明確
になった
• しかしながら,プログラムの規模が大きくなった場合,
一目で全体構造を捉えることが難しくなる
• コードが長くなるから
一目で分かるメインメソッド
• メイン関数に書いてある記述をメソッドで外部化するこ
とで,プログラムの構造をより見えやすくしよう

IPOをメソッドにする
シンプルでビューティフルなメソッドになる
 プログラムの全体の構造が一目で把握できる

\begin{verbatim}
private void run() throws Exception {
    double input = input();
    double output = process(input);
    output (output);
}
\end{verbatim}

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=33mm 18mm 15mm 35mm,clip]
   {run.pdf}
  \caption{メソッドの階層構造}
 \end{center}
\end{figure}

メソッドを利用する目的

同じ処理を複数回利用する

• 一般的なメソッドの利用目的であり,保守性の向上な
どでメリットがある

処理の構造を明確化する

• メソッドには,処理の構造を明確にするという役割が
ある.

• これはすなわち,1度しか呼ばないメソッドであっても,
その作成価値はあるということでもある.

\section{メソッドのシグネチャ}

メソッドのシグネチャと戻り値の型
メソッドのシグネチャ(signature)とは?
 あるメソッドと他のメソッドを区別するためのもの
シグネチャの構成要素(一般的なもの)
Java言語では、
 メソッド名
他に限定子・例外も
シグネチャに含めます
 引数の数と型
 戻り値の型・・・(Java言語では考慮されない)
シグネチャの例
 public static void main(String[] args)
 メソッド名:
 引数の数と型:
 戻り値の型:
main
Stringの配列が1つ
void

メソッドの「宣言」と「実装」

メソッドの宣言とは?

 メソッドの「シグネチャ」を定義すること

メソッドの実装とは?

 メソッドの宣言に基づき,メソッドの実際の振る舞
いを記述すること

「宣言」と「実装」を分離して考える理由

 他のメソッドから,あるメソッドを呼び出す場合,
呼び出し側はそのメソッドの「宣言」に適合してい
ればよい

 「実装」については考えなくてもよい
Java言語の宣言と実装
通常,Java言語では,メソッドの「宣言」と
「実装」を同時に取り扱う

\begin{figure}
 \begin{center}
  %trim option's parameter order: left bottom right top
  \includegraphics[width=0.8\textwidth, trim=15mm 15mm 15mm 75mm,clip]
   {signature.pdf}
  \caption{Java言語の宣言と実装}
 \end{center}
\end{figure}

\newpage

\chapter{例題と演習}
\section{例題}
%スライドpp.90--97

この演習では・・・を目指す．

\newpage
\subsection{Square0: 自乗を計算するプログラム}
最近はあまり見かけないが，一昔前のJava言語の入門書には最初のプログラム
の例として右頁のようなコードが載っていたものである．

このコードはとても問題のあるコードである．一言で言えば，オブジェクト指
向言語たるJavaらしくないコードなのだ．

しかし，前述のとおり，Java言語を
初心者に教えようとすると，このコードのような例を最初に取り上げるのは致
し方がない面がある．

1行目から8行目辺りまでを「おまじない」として，9行目から15行目までの解
説をする所からはじめるであろう．

1行目はsquareというパッケージ宣言です（正式は？）\marginpar{パッケージ
については・・・を参照．}．

\begin{例題}
 インスタンス生成を用いて書き直せ．
\end{例題}

\newpage
\input{source_code/workspace/Square0/src/square/Square.java.tex}
\newpage

\subsection{Square1: クラスとインスタンス}

\texttt{new}演算子を用い，インスタンスを作成して，メソッドを呼び出す，
オブジェクト指向らしいプログラムにしたのが左頁のソースコードである．

それでは，次の例題を考えてみよう．

\begin{例題}
 Squareクラスの\texttt{run()}メソッド内のコードのうち，入力・処理・
 出力はそれぞれどれか．
\end{例題}

・・・は出力なのだろうんか？
？で述べたとおり，目的手段の考え方をしよう．
・・・の目的はなにか．

では，実際に，コメント・ブロックを用いてソースコードを分けてみてほしい．

\begin{例題}
ブロックによる構造の整理 

プログラムを編集し,コメントブロックにより
IPOごとに整理しなさい


\end{例題}
 ヒント プロセスとアウトプットを分離するためには,少々工夫が
必要

\newpage
\input{source_code/workspace/Square1/src/square/Square.java.tex}
\newpage


\subsection{Square2: コメント・ブロック}

答えは次の通りだ．

最初のコードから変わった点
プログラムの全体構造

 Input-Process-Outputという構造が人間にとって分
かりやすい

 保守性の向上(人に優しいプログラミング)

23行がポイントだ．
人間にとってわかりやすくなった代償として，変数が1つ増えている．

\begin{例題}
 「自乗を計算する」プログラムのメソッド化

 自乗を計算するプログラムのIPOをメソッドにして
みよう
\end{例題}

IPOの各メソッドのシグネチャは次のとおりとする．

\begin{verbatim}
入力: private double input() throws IOException
処理: private double process(double input)
出力: private void output(double output)
\end{verbatim}

\newpage
\input{source_code/workspace/Square2/src/square/Square.java.tex}
\newpage

\subsection{Square3: IPOをメソッドにする}
IPOをメソッドにしたコードは次のとおりになる．

\newpage
\input{source_code/workspace/Square3/src/square/Square.java.tex}
\newpage

\section{演習問題}
\begin{演習}
 右頁のプログラムをコメント・ブロックにより入力・処理・出力の構造を明
 確にせよ．
\end{演習}
\newpage
\input{source_code/workspace/Division1/src/division/Division.java.tex}
\newpage
\chapter{ほげほげ}

\section{複数の値を束ねるクラス}
演習？で取り上げた「割り算を計算する」プログラムは，

• このプログラムは,割られる数と割る数を入力に取り,
商と余を返す

• 即ち,入力値が2つ,出力値も2つである

Java言語のメソッドの制限

• Java言語のメソッドは,複数の値を入力として受け取る
ことはできるが,複数の値を出力することができない

• この問題を解決するには,どうしたらよいだろうか?

\section{Javaのメソッドの文法上の制約}

Java言語のメソッドは,次の構造である

 出力値=メソッド(入力値1,入力値2,...入力値n)

割り算を計算するプログラムには,出力値が2つあ
る

 自乗を計算するプログラムの場合と同様の方法で入出力を
メソッドにすることはできない

 Eclipseのリファクタリング機能も使えない
この問題を「クラス」を導入することで解決しよう

 注意)

 他のプログラミング言語(LispやPerlなど)は,複数の出力値
を返すメソッド(関数)を作成できるものもある

複数の値を束ねる手段としてのクラス
ここでは,Javaのクラスが持つ多くの性質のう
ち,「複数の値を束ねる」側面を使ってみよう

入出力クラスを使ったメソッド

次のようなコードが可能になるため,複数の入
力値・出力値をメソッドに引き渡すことができ
る

\begin{verbatim}
	入力クラス input;
	出力クラス output;
	output = 処理(input)
\end{verbatim}

なお,別な方法として,参照渡しを使って次のよう
にすることもできるが,まずはシンプルな方法を採
用する

\begin{verbatim}
	入力クラス input = new 入力クラス();
	出力クラス output = new 出力クラス();
	処理(input, output)
\end{verbatim}

\newpage
\chapter{例題と演習}
\section{ほげほげ}
この例題は・・・・演習は・・・．
\newpage
\section{例題}
\subsection{Division2: 割り算の入出力値にクラスを導入}

右頁のコードは・・・


「割る数と割られる数」は次のクラスで表そう．
\input{source_code/workspace/Division3/src/division/DividendAndDivisor.java.tex}

「商と余」は次のクラスを用いる．
\input{source_code/workspace/Division3/src/division/QuotientAndRemainder.java.tex}

なお，メソッドはまだ導入しなくて良い．

\newpage
\input{source_code/workspace/Division2/src/division/Division.java.tex}
\newpage
\subsection{Division3: メソッド化}
2つのクラスを導入したコードは右頁のとおりだ．
14行と25行がインスタンスを生成している部分である．

\begin{例題}
 メソッドを導入せよ．
\end{例題}

新しい\texttt{run()}は次のとおりになるだろう．

\begin{verbatim}
	private void run() throws Exception {
	    DividendAndDivisor input = input();
	    QuotientAndRemainder output = process(input);
	    output (output);
	}
\end{verbatim}

\newpage
\input{source_code/workspace/Division3/src/division/Division.java.tex}
\newpage

\section{演習}
\begin{演習}
 右頁のコードの入力・出力の値をクラスにせよ．
\end{演習}

カプセル化

\input{source_code/workspace/Square4/src/square/ValueToBeSquared.java.tex}
\input{source_code/workspace/Square4/src/square/SquaredValue.java.tex}

なお，右頁のコードは演習？の解答でもある．

\newpage
\input{source_code/workspace/Square4/src/square/Square.java.tex}
\newpage

\chapter{スライドp.106以降}
\section{ほげほげ}



\newpage
\section{例題}
\subsection{Division4: フレームワーク化}

\newpage
\input{source_code/workspace/Division4/src/division/Division.java.tex}
\newpage

\subsection{Division5: }
\newpage
\input{source_code/workspace/Division5/src/division/Division.java.tex}
\newpage


\newpage
\section{演習}
\subsection{Square5: 「枠（わく）」を抽出する}

frameworkパッケージには次の2つのインタフェイスを抽出しよう．

\input{source_code/workspace/Square5/src/framework/Input.java.tex}
\input{source_code/workspace/Square5/src/framework/Output.java.tex}

すでにある入力値・出力値のクラスにそれぞれ，インタフェイスを実装する．

\input{source_code/workspace/Square5/src/square/ValueToBeSquared.java.tex}
\input{source_code/workspace/Square5/src/square/SquaredValue.java.tex}

\newpage
\input{source_code/workspace/Square5/src/square/Square.java.tex}
\newpage


\chapter{メモ}

\begin{enumerate}
 \item 名前付けと抽象化について（int x = 1; double pi = 3.14）
 \item テストを取り上げるか？
 \item パターンとアーキテクチャについて解説する？
 \item UMLの関連・依存関係について
 \item ライブコーディング
 \item 防衛的プログラミング
 \item interfaceとclassの使い分け
 \item 試行錯誤．あるべき設計を発見するまでに必要だったプロセスｖｓ手
       戻り
 \item パッケージは名前空間です，という説明をどこかでする．
\end{enumerate}

Eclipseに関するスライドpp.74--89をどうするか．


\begin{演習}
 Java言語ではクラスの名前とファイル名を一致させる必要がある．他のオブジェ
 クト指向型言語の場合を調べよ．また，クラス名とファイル名を一致させるこ
 との長所・短所について考察せよ．
\end{演習}
\end{document}
